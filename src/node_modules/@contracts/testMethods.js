
import { setAlert } from "@storage/global";
import { contractInfo } from "@storage/contract";
import { output } from "@helpers/contractTesting";
import { shortAddr } from "@helpers/main";

export const allFunctions = [ 
     {
         name:"createDragonGen0",         
         method: async (dna) => await createDragon(dna),
         isCall:false,
         default:"8051882761572390"
     },
     {
        name:"getDragon",         
        method: async (id) => await getDragon(id),
        isCall:true,
        default:"1"
    },
    {
        name:"getAllYourDragonIds",         
        method: async () => await getAllYourDragonIds(),
        isCall:true,
        default:null
    },
    {        
        name:"getDetailsAllCats",         
        method: async (catIds) => await getDetailsAllCats(catIds),
        isCall:true,
        default:"[0,1]"
    },
    {
        name:"breedCats",         
        method: async (catIds) => await breedCats(catIds),
        isCall:false,
        default:"[0,1]"
    },
    {
        name:"getAllCatIdsOnSale",         
        method: async () => await getAllCatIdsOnSale(),
        isCall:true,
        default:null
    },
]

export async function getAllYourDragonIds() {

    let contractData = await contractInfo()
    
    try {
        let catIds = []
        await contractData.interfaces.dragon.methods.getAllYourDragonIds().call({}, function (err, idsTokens) {
            if (err)  setAlert(err,'warning')
            catIds = idsTokens
        })

        output(catIds,"Dragons of "+ shortAddr(contractData.account))
    
    }
    catch (error) {
        console.error("In getAllYourCatIds(): " + error)
    }
}

export async function createDragon(dna) {
    try {
        
		let contractData = await contractInfo()
                
        await contractData.interfaces.dragon.methods.createDragonGen0(dna).send({}, function (err, txHash) {
            if (err) setAlert(err,'warning')
            else setAlert("Gen 0 created successfully. TxHash : " + txHash,'success')
        })
    } catch (error) {
        console.log(error)
        setAlert(error,'danger')
    }
}


export async function getDragon(dragonId) {

    let contractData = await contractInfo()
                
    try {
        let dragon;
        await contractData.interfaces.dragon.methods.getDragon(dragonId).call({},
         function (errMsg, dragonInfo) {
            if  (errMsg){
                console.error(errMsg)
            }     
            dragon = dragonInfo        
        })        
        output(dragon,"dragon Object:")
        return dragon

    } catch (error) {
        console.error(error)
    }
}

export async function getDetailsAllCats(catIds) {

    catIds = JSON.parse(catIds)
    console.log(catIds)
    
    try {
        let allCats = []        
        for (let i = 0; i < catIds.length; i++) {
            const cat = await getCatDetails(catIds[i])
            allCats.push(cat)
        }        
        setAlert('Success','success')          
    }
    catch (error) {
        setAlert(error,'danger')
    }
}


async function breedCats(ids) {
    
    let contractData = await contractInfo()

    ids =  JSON.parse(ids)
    let mumId = ids[0]
    let dadId = ids[1]

    try {
        await contractData.interfaces.dragon.methods.breed(mumId, dadId).send({}, function (err, txHash) {
            if (err) throw "Error returned from 'contractInfo().interfaces.dragon.methods.breed(mumId, dadId).send({}': " + err
            else {
                console.log(txHash)
                setAlert('Success transaction : TxHash :'+ txHash ,'success')    
                return txHash
            }
        })
    }
    catch (error) {
        console.log("In breedCats(): " + error)
        setAlert(error,'danger')
    }
}

// Marketplace Contract Events

function onMarketplaceEvent(uiCallbackFunc) {
    Instance_Of_Marketplace.events.MarketTransaction().on('data', function (event) {
        uiCallbackFunc(event.returnValues)
    })
        .on('error', function (error, receipt) {
            console.log("Market Transaction Event Error")
            console.log(error)
            console.log(receipt)
        })
}

// Marketplace Contract Interface functions

async function getAllCatIdsOnSale() {

    let contractData = await contractInfo()

    try {  
        await contractData.interfaces.marketplace.methods.getAllTokenOnSale().call({}, function (err, idsTokensOnSale) {
            if (err){
                setAlert(err,'warning')
                return
            } 
            put(idsTokensOnSale,"idsTokensOnSale")
            setAlert('Success' ,'success')               
        })
    }
    catch (error) {
        setAlert(error ,'danger')   
        console.log("In getAllCatIdsOnSale(): " + error)
    }
}

async function getDetailsOfAllCatsForSale(catIds) {
    try {
        let allCatsForSale = []

        for (let i = 0; i < catIds.length; i++) {
            const cat = await getCatDetails(catIds[i])
            const forSale = await getForSaleDetails(catIds[i])
            const catForSale = { ...cat, ...forSale }
            allCatsForSale.push(catForSale)
        }
        return allCatsForSale
    }
    catch (error) {
        console.log("Error from getDetailsOfAllCatsForSale(catIds): " + error)
    }
}

async function isCatOnSale(catId) {
    try {
        let isOnSale
        await Instance_Of_Marketplace.methods.isTokenOnSale(catId).call({}, function (errMsg, onSale) {
            if (errMsg) throw new Error(errMsg)
            isOnSale = onSale
        })
        return isOnSale
    }
    catch (error) {
        console.log("Error from isCatOnSale(catId): " + error)
        console.log("Defaulting to returning false ... continuing")
        return false
    }
}

async function getForSaleDetails(catId) {
    try {
        const forSaleDetails = {
            id: undefined,
            sellerAddress: undefined,
            priceInWei: undefined,
            active: undefined,
            price: undefined
        }

        await Instance_Of_Marketplace.methods.getOffer(catId).call({}, function (errMsg, offer) {
            if (errMsg) throw new Error(errMsg)
            if (catId != offer.tokenId) throw new Error(`Internal error - tokenId (${offer.tokenId}) returned by getOffer(catId) doesn't match catId (${catId})!?`)

            forSaleDetails.id = offer.tokenId
            forSaleDetails.sellerAddress = offer.seller
            forSaleDetails.priceInWei = offer.price
            forSaleDetails.active = offer.active

            // Convert wei price to ether
            forSaleDetails.price = web3.utils.fromWei(offer.price, 'ether')
        })
        return forSaleDetails
    }
    catch (error) {
        console.log("Error from getForSaleDetails(catId): " + error)
    }
}

async function setMarketplaceApproval() {
    try {
        const isMarketplaceAnOperator = await contractInfo().interfaces.dragon.methods.isApprovedForAll(User, MARKETPLACE_ADDRESS).call()

        if (isMarketplaceAnOperator == false) {
            await contractInfo().interfaces.dragon.methods.setApprovalForAll(MARKETPLACE_ADDRESS, true).send({}, function (err, txHash) {
                if (err) console.log(err)
                else console.log(txHash)
            })
        }
    }
    catch (err) {
        console.log("Error from setMarketplaceApproval(): " + err)
        return false
    }
}

async function setForSale(catId, salePriceInWei) {
    try {
        console.log("In setForSale")
        console.log("catId: ", catId)
        console.log("salePriceInWei: ", salePriceInWei)

        await Instance_Of_Marketplace.methods.setOffer(salePriceInWei, catId).send({}, function (err, txHash) {
            if (err) {
                throw (err)
            }
            else {
                console.log(txHash)
            }
        })
    }
    catch (err) {
        console.log("Error from setForSale(catId, salePriceInWei): " + err)
    }
}

async function withdrawFromSale(catId) {
    try {
        await Instance_Of_Marketplace.methods.removeOffer(catId).send({}, function (err, txHash) {
            if (err) {
                throw (err)
            }
            else {
                console.log(txHash)
            }
        })
    }
    catch (err) {
        console.log("Error from withdrawFromSale(catId): " + err)
    }
}

async function buyKitty(tokenId, priceInWei) {
    try {
        await Instance_Of_Marketplace.methods.buyKitty(tokenId).send({ value: priceInWei }, function (err, txHash) {
            if (err) {
                throw (err)
            }
            else {
                console.log(txHash)
            }
        })
    }
    catch (err) {
        console.log("Error from buyKitty(tokenId): " + err)
    }
}

