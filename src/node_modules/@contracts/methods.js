
import { setAlert } from "@storage/alerts";
import { contractInfo } from "@storage/contract";
import { setUserDragons, getUserDragons } from "@storage/dragon";
import { getWei, getEth } from "@helpers/main";

const TokenType = { Unknown: 0, Dna: 1, Egg: 2, Dragon: 3 }
Object.freeze(TokenType)
const OfferType = { NoOffer: 0, ForSale: 1, ForRent: 2, ForSaleOrRent: 3 }
Object.freeze(OfferType)

export async function createDragon(dna) {
    try {

        let contractData = await contractInfo()

        await contractData.interfaces.dragon.methods.createDragonGen0(dna).send({}, function (err, txHash) {
            if (err) setAlert(err, 'warning')
            else setAlert("Gen 0 created successfully. TxHash : " + txHash, 'success')
        })
    } catch (error) {
        setAlert(error, 'danger')
    }
}

export async function breed(mumId, dadId) {

    let contractData = await contractInfo()

    try {

        await contractData.interfaces.dragon.methods.breed(mumId, dadId).send({}, function (err, txHash) {
            if (err) setAlert(err, 'warning')
            else {
                setAlert(txHash, 'success')
                return txHash
            }
        })
    }
    catch (error) {
        console.log("In breedCats(): " + error)
    }
}

/********  DRAGON GETTERS **********/

export async function getDragon(dragonId) {

    let contractData = await contractInfo()

    try {
        let dragon;
        await contractData.interfaces.dragon.methods.getDragon(dragonId).call({},
            function (errMsg, dragonInfo) {
                if (errMsg) {
                    throw new Error(errMsg)
                    console.error(errMsg)
                }
                dragon = dragonInfo
            })
        return dragon

    } catch (error) {
        console.error(error)
    }
}

export async function getAllYourDragonIds() {

    let contractData = await contractInfo()

    try {
        let catIds = []
        await contractData.interfaces.dragon.methods.getAllYourDragonIds().call({}, function (err, idsTokens) {
            if (err) console.error("Error from getAllYourKittyIds().call(): " + err)
            catIds = idsTokens
        })
        return catIds
    }
    catch (error) {
        console.error("In getAllYourCatIds(): " + error)
    }
}

export async function getDetailsAllDragons(dragonIds) {
    try {
        let allDragons = []
        let isApproved = await isApprovedForAll()

        for (let i = 0; i < dragonIds.length; i++) {

            const dragon = await getDragon(dragonIds[i])
            //Approval handler. Single or For all
            if (isApproved == true) {
                dragon.isApproved = isApproved
            } else {
                let approval = await getApproved(dragonIds[i])
                dragon.isApproved = approval
            }

            let offerDetails = await getForSaleOffer(dragonIds[i])
            dragon.id = dragonIds[i]
            dragon.gen = dragon.generation
            dragon.offer = offerDetails
            allDragons.push(dragon)
        }
        return allDragons
    }
    catch (error) {
        console.error("Error from getDetailsAllDragons(dragonIds): " + error)
    }
}

/********  DRAGON OFFER **********/

export async function setForSale(dragonId, price) {

    const salePriceInWei = await getWei(price)

    let saleTerms = {
        price: salePriceInWei,
        rental: {
            deposit: 0,
            minDuration: 0
        }
    }

    let contractData = await contractInfo()

    try {
        await contractData.interfaces.marketplace.methods.setOffer(
            dragonId, //tokenId,
            saleTerms,
            OfferType.ForSale,
            TokenType.Dragon
        ).send({}, async function (err, txHash) {
            if (err) {
                setAlert(err, 'warning')
            }
            else {
                setAlert('Offer create successfully: ' + txHash, 'success')
                await updateDragonOffer(dragonId)
            }
        })
    }
    catch (err) {
        console.log(err)
        console.log("Error from setForSale(dragonId, salePriceInWei): " + err)
    }
}

async function getForSaleOffer(dragonId) {

    let offer
    let offerDetails = await getForSaleDetails(dragonId);

        if (offerDetails != false) {
            offer = offerDetails;
        } else {
            offer = false
        }
    
    return offer;
}

// Marketplace Contract Interface functions

export async function getForSaleDetails(dragonId) {

    let isOnSale = await isTokenOnSale(dragonId)
    if (!isOnSale) return false;


    let contractData = await contractInfo()
    let forSaleDetails;
    try {
        await contractData.interfaces.marketplace.methods.getOffer(dragonId, TokenType.Dragon).call({}, function (err, offer) {
            if (offer == undefined) return false;

            forSaleDetails = {
                id: offer.tokenId,
                sellerAddress: offer.owner,
                price: offer.terms.sale.price,
            }
        })

        forSaleDetails.price = await getEth(forSaleDetails.price)
        return forSaleDetails
    }
    catch (error) {
        console.log("Error from getForSaleDetails(dragonId): " + error)
    }
}

export async function isTokenOnSale(dragonId) {

    let contractData = await contractInfo()

    try {
        let isOnSale
        await contractData.interfaces.marketplace.methods.isOnOffer(
            dragonId,
            OfferType.ForSale,
            TokenType.Dragon).call({}, function (err, onSale) {
                isOnSale = onSale
            })
        return isOnSale
    }
    catch (error) {
        console.log("Error from isTokenOnSale(dragonId): " + error)
        return false
    }
}

async function updateDragonOffer(dragonId) {

    let contractData = await contractInfo()
    let user_dragons = getUserDragons()
    let forSaleDetails = {}
    let isOnSale = await isTokenOnSale(dragonId)

    if (isOnSale) {
        await contractData.interfaces.marketplace.methods.getOffer(dragonId, TokenType.Dragon).call({}, async function (err, offer) {
            forSaleDetails = {
                id: offer.tokenId,
                sellerAddress: offer.owner,
                price: offer.terms.sale.price,
            }
        })
        forSaleDetails.price = await getEth(forSaleDetails.price)

    } else {
        forSaleDetails = false
    }

    user_dragons = user_dragons.map((elem) => {
        if (elem.id == dragonId) elem.offer = forSaleDetails
        return elem;
    });

    setUserDragons(user_dragons)

}

export async function getDragonsForSale() {

    let contractData = await contractInfo()

    try {
        let catIdsOnSale = []
        await contractData.interfaces.marketplace.methods.getAllTokens(OfferType.ForSale, TokenType.Dragon).call({}, function (err, idsTokensOnSale) {
            if (err) setAlert(err, 'warning')
            catIdsOnSale = idsTokensOnSale
        })
        return catIdsOnSale
    }
    catch (error) {
        setAlert(error, 'warning')
        console.log("In getDragonsForSale(): " + error)
    }
}


export async function removeDragonFromSale(tokenId) {

    let contractData = await contractInfo()

    try {
        await contractData.interfaces.marketplace.methods.removeOffer(tokenId, OfferType.ForSale, TokenType.Dragon).send({}, function (err, txHash) {
            if (err) {
                setAlert(err, 'warning')
            }
            else {
                setAlert('Offer removed Tx-Hash:' + txHash, 'success')
                updateDragonOffer(tokenId)
            }
        })
    }
    catch (err) {
        console.log("Error from removeDragonFromSale(tokenId): " + err)
    }
}

export async function buyDragon(tokenId, priceInWei) {

    let contractData = await contractInfo()

    try {
        await contractData.interfaces.marketplace.methods.buy(tokenId, TokenType.Dragon).send({ value: priceInWei }, function (err, txHash) {
            if (err) {
                setAlert(err, 'warning')
            }
            else {
                setAlert("You just bought a new Dragon! TxHash: " + txHash, 'success')
            }
        })
    }
    catch (err) {
        console.log("Error from buyKitty(tokenId): " + err)
    }
}

/******** APPROVAL  *********/

export async function singleApproval(tokenId) {

    let contractData = await contractInfo();

    try {
        const isMarketplaceApproved = await getApproved(tokenId)
        const marketplaceAddress = contractData.address.marketplace

        if (isMarketplaceApproved != true) {
            await contractData.interfaces.dragon.methods.approve(marketplaceAddress, tokenId).send({}, function (err, txHash) {
                if (err) {
                    setAlert(err, 'warning')
                } else {
                
                    setAlert('Token id: ' + tokenId + ' as been approved!', 'success') 
                    //Updating dragon
                    let user_dragons = getUserDragons()
                    user_dragons = user_dragons.map((elem) => {
                        if (elem.id == tokenId) elem.isApproved = true
                        return elem;
                    });
                    
                    setUserDragons(user_dragons)
                
                }
            })
        } else {
            setAlert('This token is already approved', 'success')
        }
    }
    catch (err) {
        console.log("Error from singleApprove(): " + err)
        setAlert(err, 'warning')
    }
}

export async function setApprovalForAll() {

    let contractData = await contractInfo();

    try {
        const isMarketplaceAnOperator = await contractData.interfaces.dragon.methods.isApprovedForAll(contractData.account, contractData.address.marketplace).call()

        if (isMarketplaceAnOperator == false) {
            await contractData.interfaces.dragon.methods.setApprovalForAll(contractData.address.marketplace, true).send({}, function (err, txHash) {
                if (err){  setAlert(err, 'warning')
                
            } else {
                  setAlert('Marketplace for all tokens', 'success') 
                  let user_dragons = getUserDragons()
                  user_dragons = user_dragons.map((elem) => {
                      elem.isApproved = true
                      return elem;
                  });                  
                  setUserDragons(user_dragons)
                }
            })
        }
    }
    catch (err) {
        console.log("Error from setMarketplaceApproval(): " + err)
        setAlert(err, 'warning')
    }
}

export async function getApproved(tokenId) {

    let contractData = await contractInfo();
    let isApproved
    const contractAddress = contractData.address.marketplace
    try {
        await contractData.interfaces.dragon.methods.getApproved(tokenId).call({}, function (err, approved) {

            if (err) console.log(err)
            if (contractAddress == approved) {
                console.log(tokenId + ' is approved')
                isApproved = true;
            } else {
                console.log('Marketplace is not approved, ' + approved)
                isApproved = false
            }

        })
    }
    catch (err) {
        console.log("Error from singleApprove(): " + err)
    }
    return isApproved
}

export async function isApprovedForAll() {

    let contractData = await contractInfo();
    try {
        const isMarketplaceAnOperator = await contractData.interfaces.dragon.methods.isApprovedForAll(contractData.account, contractData.address.marketplace).call()
        return isMarketplaceAnOperator
    } catch (error) {
        console.log('error approving marketplace for all')
    }

}

// Marketplace Contract Events

function onMarketplaceEvent(uiCallbackFunc) {
    Instance_Of_Marketplace.events.MarketTransaction().on('data', function (event) {
        uiCallbackFunc(event.returnValues)
    })
        .on('error', function (error, receipt) {
            console.log("Market Transaction Event Error")
            console.log(error)
            console.log(receipt)
        })
}
